## 二进制表示
#### （1）原反补码
* 原码：数字的二进制码，第一位为符号为（0表示正数，1表示负数）；
* 反码：符号为不动，其他位原码取反；
* 补码：正数的补码和原码相同；负数的补码是反码的符号位不变，其他位加1；
* 为什么要用补码：<br/>
补码用于计算机中数字的运算，以及0的表示。因为0既不是正数也不是负数，但原码的`00000000`和`10000000`都可以表示0，这样不规范，但使用补码表示，则只能将0表示为`00000000`；
* 当使用补码进行运算时，符号位直接参与运算；
#### （2）浮点数的表示
* float浮点数在计算机中用32位二进制数表示；
* 第1位是符号位s；2-9位是指数位e，10-32位是尾数位m
* 计算方法：s * 2<sup>e-127</sup> * m
* 符号位：1位，0表示正数，s为1；1表示负数，s为-1；
* 指数位：8位，在最终的指数计算中需要减去127；
* 尾数位：24位（包括一个附加位），如果e为0则附加位为0，否则附加位为1。
* 例子：1-10000001-01000000000000000000000：<br/>
s=1，是负数；e=129，则指数为129-127=2；e不为0，因此m有一位附加位1，m=2<sup>0</sup>+2<sup>-2</sup>=1.25，因此，该二进制数表示的浮点数为`-1 * 2 * 1.25=-5`。

## 内存泄漏和内存溢出
* 内存溢出：当内存中现在存储的数据容量超出了内存容量，会出现内存溢出错误；
* 内存泄漏：当使用完毕某些资源之后没有释放内存，会导致内存泄漏错误。

## 编译时和运行时
* 编译时：将java代码编译成.class文件的过程，这个过程只涉及纠正语法，不涉及内存方面；<br/>
* 运行时：JVM执行.class文件的过程，需要用到内存调用。

## JVM基本物理结构
![JVM物理结构图](https://github.com/ITGungnir/ForInterview/blob/master/images/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?raw=true)
* 类加载器：将JAVA的class文件加载到JVM中；
* 程序计数器：指向下一条要执行的指令，每个线程都有自己的程序计数器；执行本地方法时，程序计数器的值为undefined；
* 执行引擎：执行class字节码；
* 方法区：存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码等。方法区是线程共享的；
* 堆：存放对象与数组实例的区域，垃圾回收的主要场所，线程共享，逻辑上连续，空间上可以不连续。堆中通常存储的就是直接new出来的对象，垃圾回收器会在这些对象不使用时回收；
* 栈：栈是线程私有的，由一系列`帧`组成，每调用一个方法，就会生成一个栈帧，用于存储方法的局部变量、方法出口等信息；方法执行完成后，会自动释放方法内的局部变量。

## JVM启动流程
* 配置JVM装载环境：<br/>
（1）根据当前路径和系统版本寻找`jvm.cfg`；<br/>
（2）根据jvm.cfg中的配置，寻找`jvm.dll`，调用jvm.dll文件中定义的函数，初始化虚拟机中的函数；
* 解析虚拟机参数：<br/>
（1）对启动参数进行解析；<br/>
（2）将解析完成的数据保存到`JavaVMOption`中；<br/>
（3）处理JavaVMOption中的数据；<br/>
（4）验证参数的合理性；
* 设置线程栈大小：<br/>
获取配置中的`ThreadStackSize`参数，如果为0则设置为JVM的初始化默认值。在不同的系统中，ThreadStackSize的默认值也不同；
* 执行java main方法：<br/>
（1）新建JVM实例；<br/>
（2）加载主类的class文件（由javac编译生成）；<br/>
（3）查找main方法；<br/>
（4）执行main方法；

## JVM ClassLoader
* 什么是类加载器：<br/>
&emsp;&emsp;我们在编写完Java程序后，编译后会生成若干个.class文件，当程序运行的时候，会先加载入口函数所在的.class文件，然后调用入口函数，进而调用封装在各个.class文件中的功能。程序在启动的时候不会加载所有的.class文件，而是根据程序的需要，通过ClassLoader、根据Java类加载机制来动态的加载.class文件到内存中。
* 类加载器的类型：<br/>
（1）Bootstrap ClassLoader：启动类加载器，负责加载jre/lib目录下的.jar和.class文件，是用C++语言编写的；<br/>
（2）Extension ClassLoader：扩展加载器，负责加载jre/lib/ext目录下的.jar和.class文件；<br/>
（3）APP ClassLoader：应用程序类加载器，负责加载用户路径下的.jar和.class文件。<br/>
（4）Custom ClassLoader：自定义类加载器，负责自定义地加载文件。
* 双亲委托模型：<br/>
![](https://upload-images.jianshu.io/upload_images/3251891-d34761b5a29e065b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/212)<br/>
&emsp;&emsp;如上图，每一层的类加载器上方的类加载器称为当前类加载器的父加载器，子加载器通过组合来复用父加载器的代码，而不是使用继承。<br/>
&emsp;&emsp;在某个类加载器加载.class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(BootstrapClassLoader)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类。<br/>
&emsp;&emsp;双亲委托模型最大的好处是，Java类和它的类加载器一起具备了一种层次关系，保护了程序的稳定性。
* 类加载的过程：<br/>
![](https://images2015.cnblogs.com/blog/870109/201605/870109-20160503213708857-429280187.png)<br/>
&emsp;&emsp;类加载的过程如上图所示。加载、验证、准备、初始化、卸载阶段的顺序是固定的，而解析不一定在什么时候进行，某些时候可能在初始化之后进行，这是为了适应Java类的动态绑定（运行时绑定）。<br/>
（1）加载：通过一个类的全限定名获取其二进制字节流；将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；在堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问接口。<br/>
（2）验证：确保Class对象中的信息（文件格式、符号引用、元数据、字节码等）符合当前虚拟机的要求；<br/>
（3）准备：正式为类中的变量分配内存并初始化类变量。如果在变量声明时不显式赋值，则会自动赋默认值。<br/>
（4）解析：判断字段、方法等是否可用。<br/>
（5）初始化：正式执行Java代码中的类构造器中的代码。<br/>
（6）使用：使用类加载器加载的数据。<br/>
（7）卸载：类使用完后，将类从内存中卸载。

## Java反射机制
* 什么是反射：<br/>
在运行状态下，对于任意一个类，都能够读取它的.class文件，从而获取这个类完整的构造以及所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法或属性
* 反射的运用：<br/>
  * 获取类的Class对象：
    ```java
    Class cls = person.getClass(); // 方法一
    Class cls = person.class; // 方法二
    Class cls = Class.forName("Person"); // 方法三
    ```
  * 获取类的包名和类名：
    ```java
    String package = cls.getPackage().getName(); // 获取包名
    String clsName = cls.getClass().getName(); // 获取类名
    ```
  * 创建类对象：
    ```java
    Person person = (Person) cls.newInstance(); // 通过Class对象创建Person对象
    ```
  * 获取类中的信息：构造方法Constructor、方法Method、属性Field、注解Annotation

## JVM 垃圾回收
* 垃圾回收算法：<br/>
  * 标记-清除算法：<br/>
  标记可回收的内存，然后回收它们。<br/>
  缺点：效率低；清理之后会产生很多碎片。
  * 标记-整理算法：<br/>
  标记可回收的内存并回收，然后将存活的对象移到一端。<br/>
  优点：产生了连续的空间。
  * 复制算法：<br/>
  将内存分为大小相等的两块，每次只使用其中一块。当一块内存用完之后，就将存活的对象复制到另外一块内存区域并将本块内存清理。<br/>
  优点：大大降低了内存空间使用率。
  * 分代收集算法：<br/>
  将Java堆分为新生代和老年代。新生代采用复制算法，存放新生对象；老年代采用标记-整理算法，对象存活率较高。<br/>
  当前的商业虚拟机基本采用的都是分代收集算法。
* 堆存储划分：<br/>
Java堆被分为两部分：新生代区和老年代区，新生代区又分为Eden区和Survivor区。<br/>
新创建的对象会创建在Eden区；在发生一次GC后，Eden区中的对象会被移动到Survivor区中；Survivor区中的对象在满足一定年纪后会被移动到老年代区中。<br/>
Java堆中，新生代区:老年代区=1:2；新生代区中Eden:Survivor=8:2。
* 垃圾收集器-G1：<br/>
  将新生代老生代进一步分为多个region，每次gc可以针对部分region而不是整个堆内存。

## 进程和线程的区别
（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br/>
（2）进程是系统进行资源分配和调度的一个独立单位；线程是操作系统可识别的最小执行和调度单位；<br/>
（3）同一进程中的所有线程共享本进程的地址空间，而进程之间则是独立的地址空间；<br/>
（4）进程在一个时间只能干一件事，而线程可以并发执行；<br/>
（5）就Android系统而言，线程间通信可以使用Handler、AsyncTask、HandlerThread、IntentService等，而进程间通信可以使用AIDL、Messenger、ContentProvider等。

## 死锁
&emsp;&emsp;死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态。死锁的一个经典问题是哲学家进餐问题，当同一时间点所有哲学家都拿起了左边的筷子，都在等在右边的筷子的时候，就会出现死锁问题。<br/>
&emsp;&emsp;死锁问题需要满足四个必要条件：第一，互斥条件，即资源不能共享，同一时间只有一个进程可以使用；第二，请求与保持条件，即已得到资源的进程可以再次申请新的资源；第三，非剥夺条件，即已分配的资源不能从进程中被强制剥夺；第四，循环等待条件，即系统中若干进程组成环路，该环路中的每个进程都在等待相邻进程正占用的资源。<br/>
&emsp;&emsp;避免死锁的方法：第一，按同一顺序访问对象；第二，保持事务简短并处于一个批处理中；第三，死锁在发生一端时间之后，发生死锁的进程释放所有资源，然后重新争夺资源。